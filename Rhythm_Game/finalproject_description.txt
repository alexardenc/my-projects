We created a video game called “Baddie Boogie”. It is a top-down game in which enemies are generated randomly around a playing board. The enemies move according to the downbeats of the song playing and the user attacks them to gain points.  The user must move on beat with the music or else health will be lost. The user must attack baddies and dragons to gain 5 score points for each.  Once the song is completed, the user wins!


Alex created the GUI systems and animation hierarchy. There is a main menu, highscore, instructions, win, and lose screens. The home screen includes a dragon moving across the screen and spitting fire, which is our animation. This animation is created from the Icon class which initiates the display and movement. Once in the game, the GUI shows the user score, health bar, controls, a rectangle that indicates beat reset, and a button to Exit. When the user fails to kill a monster and they are on the same square, health decreases by 5. When the hero is on the same square as fire, health decreases by 1. This is all handled in the Healthbar class with the checkHealth() and reset() functions.  There is also a flashing ellipse indicating when the hero is able to attack (cannot attack mindlessly back to back).  The main file holds functions keyPressed() to process user input, mousePressed() to process navigation, display_home() to show main menu, and other functions to display the various GUI screens.  I created the Button class to handle all of the buttons in the program. This includes the main menu screen, back (when on scores or instructions page), and exit (when in game).


Kendall created the Board, Barrier, Baddie, and Dragon classes. The Barrier class is a simple class with a display() method that creates a brown square to represent a barrier that the hero cannot pass through on the board. The Board class creates a 13x9 game board made up of two colored tiles that switch colors with every beat of the song by calling the method switch_colors(). The sprites for baddies, dragons, and dragon fire are loaded for use in creating characters. In initialization several arrays are created, a 2D list keeps track of what board tiles are occupied, a 1D list keeps track of all barriers on the board, and two array lists keep track of baddies and dragons present on the board at any given time. Lastly, the hero is initialized. Within the board class there are several methods for use during gameplay. The method getScore() returns the current score of the game, is_empty() returns whether a board tile is occupied for use in movement and creation of new characters, is_surrounded() returns if a character is surrounded and unable to move, is_barrier() returns if there is a barrier present in order to prevent the hero from moving through those tiles, and check_collision() checks to see if the hero has encountered any baddies or dragons. Every 10th beat the method add_baddie() is called, which randomly adds a dragon or baddie to their respective arrays with equal probability. The new character is added in a tile that does not contain the hero, a barrier, or any other character. Every 5th beat the method move_baddies() is called to move every baddie and dragon. Every character in the baddie and dragon arrays has a temporary object created, which is then moved to an unoccupied tile and placed back in the array, replacing the original character that was copied. Last, there is a check for any collisions. Every other beat each dragon in the array has its fire moved to a new position with the method move_fires(). When the user presses any of the attack keys, the method remove_baddies() is called to check if there are any baddies or dragons in the tile corresponding to the heroes attack, and any characters in that tile are removed from their arrays. Every draw loop the display() method is called, the board is displayed along with all barriers, baddies, dragons, and the hero, and all characters are advanced.


The Dragon inherits from the Baddie class. During initialization a timer is started that will control the display of the sprites for both classes. The method test_move() generates a random new position for the character, which is then tested in the Board class to see if it is unoccupied. The advance_sprite() method advances the sprite by way of the timer. The display() method advances the sprite and displays to the screen. The Dragon class adds a method test_fire(), which much like test_move(), returns a position for the fire relative to the dragon, which is then tested in the Board class to see if that tile is unoccupied. 


Ethan created the Timer, SpriteTimer, and Hero classes. He also implemented the importation and saving of csv data files for the game’s highscores, and included the sound for the program. The Timer class is used to determine the movement of the monsters and the color changes of the playing board. We determined the approximate tempo of the game song in milliseconds, given by the variable interval; and after each beat interval passed, we movement of baddies, dragons, and the board were allowed. For user input, the same timer class is used. However, this timer is also given an integer “cushion” (in units of milliseconds) upon initiation. For each draw loop, we call the method timer.toggleActive(), which checks if the current time is within a range of the tempo that is interval - cushion to interval + cushion. If a user input for movement is given any time during this period, the Hero moves. If the user input for movement is given any time outside of this period, the Hero still moves, but loses health as a consequence. Once the timer exceed the value interval + cushion. The timer is reset to millis() - cushion, to make sure that the cushion overlaps with the next beat. Note that because the timer cannot detect the beat of the song, it occasionally gets out of sync with the song. For this, we included a beat reset functionality that is triggered when the user hits spacebar. It must be pressed on the downbeat. The SpriteTimer class is also a timer class, but is more basic. It takes an interval as a parameter in the initialization, and then sends a boolean variable that indicates when the time to change a sprite image has passed to the Baddie and Dragon classes. The Hero class has position and health variables. These are modified when the user uses keystrokes to move or is hurt by an enemy, respectively. The file also includes a csv file “playerScores1.csv,” which is read in by the program as a Table object. This is where the highscores of the game are stored. When the user finishes the game or loses, they are prompted to enter their name. Their score is then compared with the other values in the csv file, and then placed in ascending order in the table. We also loaded in 2 .mp3 soundFiles for the game song, and a song that is used for all screens other than the game screen. There is also a .wav file that is triggered upon mouse button presses.

The sprite images for the hero were taken from https://opengameart.org/content/running-caveman-spritesheet by the author Hapiel. The images for the music notes, dragon sprites, and baddie sprites were also taken from opengameart.org.
